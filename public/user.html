<!DOCTYPE html>
<html>
<body>
<h2>User</h2>
<button id="callBtn">Call NOC</button>
<p id="status">Idle</p>
<div id="log"></div>

<script src="/socket.io/socket.io.js"></script>
<script>
// Polyfill for older browsers
if (!navigator.mediaDevices) {
  navigator.mediaDevices = {};
}
if (!navigator.mediaDevices.getUserMedia) {
  navigator.mediaDevices.getUserMedia = function(constraints) {
    const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    if (!getUserMedia) {
      return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
    }
    return new Promise((resolve, reject) => {
      getUserMedia.call(navigator, constraints, resolve, reject);
    });
  };
}

const ws = io();
ws.emit("join", "user");

const logDiv = document.getElementById("log");
const status = document.getElementById("status");

let pc, localStream;

function log(msg){ logDiv.innerHTML += msg + "<br>"; }

document.getElementById("callBtn").onclick = async () => {
  // Prevent multiple clicks
  const callBtn = document.getElementById("callBtn");
  callBtn.disabled = true;

  try {
    status.innerText = "Calling NOC...";
    log("Starting call to NOC...");

    // Check if media devices are available
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error("Media devices not available. Please use HTTPS or localhost");
    }

    log("Requesting microphone access...");
    localStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });
    log("Microphone access granted");

    pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    // Add connection state monitoring
    pc.onconnectionstatechange = () => {
      log(`Connection state: ${pc.connectionState}`);
      if (pc.connectionState === 'connected') {
        status.innerText = "Voice call connected";
        log("WebRTC connection established successfully!");
      }
    };

    pc.oniceconnectionstatechange = () => {
      log(`ICE connection state: ${pc.iceConnectionState}`);
    };
    
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
      log("Added local audio track");
    });

    const audio = document.createElement("audio");
    audio.autoplay = true;
    audio.controls = true; // Add controls for debugging
    pc.ontrack = e => {
      log("Received remote audio stream");
      audio.srcObject = e.streams[0];
      log("Voice connection established - audio element created");
    };
    document.body.appendChild(audio);

    pc.onicecandidate = e => {
      if (e.candidate) {
        // Send the complete candidate object, not just the candidate string
        ws.emit("signal", { to: "noc", data: {
          candidate: e.candidate.candidate,
          sdpMid: e.candidate.sdpMid,
          sdpMLineIndex: e.candidate.sdpMLineIndex
        }});
        log("Sent ICE candidate to NOC");
      } else {
        log("ICE gathering completed");
      }
    };

    startSTT("User said: ");
    ws.emit("call_noc");
    log("Call request sent to NOC");
  } catch (error) {
    log("Error starting call: " + error.message);
    status.innerText = "Error starting call";
    // Re-enable button on error
    callBtn.disabled = false;
  }
};

ws.on("call_accepted", async () => {
  try {
    status.innerText = "Call accepted, establishing connection...";
    log("NOC accepted the call, creating offer...");

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    ws.emit("signal", { to: "noc", data: offer });
    log("Sent offer to NOC");
  } catch (error) {
    log("Error creating offer: " + error.message);
    status.innerText = "Error establishing connection";
  }
});

ws.on("signal", async data => {
  if (!pc) {
    log("ERROR: Received signal but no peer connection exists");
    return;
  }

  try {
    if (data.type === "answer") {
      log("Received answer from NOC");
      log("Answer SDP: " + JSON.stringify(data).substring(0, 100) + "...");
      
      await pc.setRemoteDescription(new RTCSessionDescription(data));
      status.innerText = "Connected to NOC";
      log("Connection established with NOC");
    }

    if (data.candidate) {
      // Validate that data.candidate is a proper ICE candidate object
      if (typeof data.candidate === 'string' && data.candidate.startsWith('candidate:')) {
        // Handle string candidates (legacy format)
        try {
          await pc.addIceCandidate(new RTCIceCandidate({
            candidate: data.candidate,
            sdpMid: data.sdpMid || null,
            sdpMLineIndex: data.sdpMLineIndex || 0
          }));
          log("Added ICE candidate from NOC (string format)");
        } catch (candidateError) {
          log("Error adding string ICE candidate: " + candidateError.message);
        }
      } else if (data.candidate && typeof data.candidate === 'object') {
        // Handle object candidates (proper format)
        try {
          await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
          log("Added ICE candidate from NOC (object format)");
        } catch (candidateError) {
          log("Error adding object ICE candidate: " + candidateError.message);
        }
      } else {
        log("Received invalid ICE candidate data: " + JSON.stringify(data.candidate));
      }
    }
  } catch (error) {
    log("Error handling signal: " + error.message);
    log("Stack: " + error.stack);
  }
});

// Speech-to-text
function startSTT(prefix){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) return;
  const r = new SR();
  r.continuous = true;
  r.interimResults = false;
  r.onresult = e => log(prefix + e.results[e.results.length-1][0].transcript);
  r.start();
}
</script>
</body>
</html>
